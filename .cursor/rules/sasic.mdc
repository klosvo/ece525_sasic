---
alwaysApply: true
---
Project context
This repository is a class project implementing Synaptic Input Consolidation (SIC) on neural networks.
I am implementing a sparsity-aware SIC (SASIC) extension on top of the existing SIC pipeline.
My working branch is kama, which is currently identical to main locally.
The code should be written and maintained for Linux only and is intended to run on a university HPC system (interactive or simple batch runs), not on macOS.


Environment assumptions

Target OS: Linux. Do not generate macOS-specific instructions, paths, or workarounds.
Assume Python + PyTorch and CUDA are available through a conda environment or modules, but do not hard-code module names or environment paths unless explicitly given.
Do not assume Slurm or any specific scheduler.
    When writing run instructions or scripts, use plain bash command examples like python path/to/script.py --args ....
    If a scheduler is needed, you must ask for details first rather than guessing (no sbatch, qsub, etc. unless I explicitly request it).


Git and shared-repo safety

This is a shared class repository on someone else’s GitHub.
You must not:
    Create or delete remote branches.
    Run or suggest git push, git pull, git push --force, or any command that modifies remotes.
    Rewrite git history.
You may refer to local-only commands like:
    git status, git diff, git log, git add, git commit        
    but do not assume that I will run them unless I ask.
Never rename or remove major directories or top-level modules without being explicitly asked.


Editing style and scope

Prefer small, focused edits that touch only the files and functions explicitly relevant to the current request.
Before editing, summarize the existing code that you plan to change:
    What the current functions/classes do.
    How they fit into the SIC pipeline.
When you propose changes:
    Show them as concise diffs or clearly delimited code blocks (old vs new or “replace this function with…”).
    Avoid broad refactors or style-only rewrites unless I explicitly request them.
Do not introduce significant new dependencies or frameworks unless explicitly asked; prefer reusing existing patterns and libraries in the repo.


SASIC / SIC–specific behavior

Treat the existing SIC implementation as the baseline that must remain working.
SASIC should be added as a configurable extension:
    New modes/options (e.g., SASIC variants, k* heuristic) should be controlled via flags/config keys, not hard-coded.
    Default behavior should remain identical to the current baseline SIC when SASIC is disabled.
When asked to design or implement SASIC features, you should:
    First identify the relevant entrypoints, configuration files, and core SIC functions.
    Propose a short design: how to extend configs, where to insert SASIC logic, and how to avoid code duplication.
    Only then propose concrete code changes.


Running and profiling experiments

When suggesting how to run experiments, use simple Linux command-line examples, e.g.:
    python SIC/run_sic.py --config SIC/config/sic.yaml
Do not assume multi-GPU or distributed training unless I explicitly say so.
When adding or modifying logging/profiling code, keep it:
    Lightweight and optional.
    Focused on recording runtime, compression, and accuracy metrics relevant to SIC/SASIC.


Interactivity and clarification

If a requested change depends on environment details (e.g., scheduler, conda env name, exact Python version) that are not present in the codebase, do not guess.
    Instead, clearly state what information is missing and ask me to provide it.
When in doubt between multiple design options (e.g., how to structure SASIC modes), briefly list the options and their trade-offs, then either:
    choose a reasonable default and say why, or
    ask me which option I prefer.


Testing Policy

Testing requirements
For any non-trivial change (new function, new SASIC mode, changes to SIC/SASIC logic, or anything that touches sic_alg.py, sic_utils.py, or activation-stat utilities), you must also propose a small, fast test.

“Non-trivial” excludes simple one-line refactors, comment changes, or pure formatting.


Test types
Prefer micro-tests for helpers: tests that run on synthetic data / tensors, without loading real datasets or full models.

For pipeline changes, propose a smoke-test config (tiny model, few batches, small k-range) that can verify the change in seconds.


Constraints
Tests must be runnable on CPU only and should complete in well under 10 seconds for micro-tests and under ~1 minute for smoke tests.

Do not add heavy new test dependencies; use the existing stack (PyTorch, numpy, etc.).

Keep test changes localized: either a small test function/script or a minimal config file.


Behavior
When you propose a non-trivial code change, always:

Mention what kind of test should accompany it (micro-test or smoke-test).

Describe where it should live (e.g., a small test script or a helper in an existing test/util file).

If I explicitly say "skip tests for this trivial change", you may omit them for that edit only.